<!DOCTYPE html>
<html>
<body>
<script type="text/javascript">
//$("#mainMapTitle").html("Selected 2011 US County/Municipality Statistics");
$('#mainScatterplotMapLegend').html("<h4>Plot Legend</h4>" +
    "<p>Data point size indicates relative population of county</p>" +
    "<p><strong>Data source:</strong> US Census American Community Survey (ACS) Single Year Estimates for 2007-2011</p>");
$("#mainScatterplotMapLegend").show();

$(function() {
    $( "#slider" ).slider({
        value:2011,
        min: 2007,
        max: 2011,
        step: 1,
        slide: function( event, ui ) {
            $( "#amount" ).val( "$" + ui.value );
        }
    });
    $( "#amount" ).val( "$" + $( "#slider" ).slider( "value" ) );
});

var fieldLabels = [];
var firstPlot = true;
var transitionSpeed = 6000;

var defaultXMetric = "medianHouseInc";
var defaultYMetric = "medianHomeVal";
var defaultXTitle = "Median Household Income ($)";
var defaultYTitle = "Median Home Value ($)";

//Width and height
var margin = {top: 20, right: 20, bottom: 60, left: 100},
        theWidth = width - margin.left - margin.right,
        theHeight = height - margin.top - margin.bottom;

var miniChartWidth = 210;
var miniChartHeight = 220;
var miniRadius = (miniChartWidth-20)/2;
var miniChartMargin = 10;
var miniChartTranslate = miniRadius + miniChartMargin;

var x = d3.scale.linear()
        .nice()
        .range([0, theWidth]);

var y = d3.scale.linear()
        .nice()
        .range([theHeight, 0]);

var z = d3.scale.linear()
        .range([4, 15]);

var xAxis = d3.svg.axis()
        .scale(x)
        .orient("bottom");

var yAxis = d3.svg.axis()
        .scale(y)
        .orient("left");

function scaleAxes(selectedData){
    x.domain(d3.extent(selectedData, function(d) { return d[1]; }));
    y.domain(d3.extent(selectedData, function(d) { return d[2]; }));
    z.domain(d3.extent(selectedData, function(d) { return d[3]; }));
}

//get data and parse it
d3.json('data/data_output_locale_census_data_11-min.json', function(error, theData)
{
    if (error){console.log("Error: " + error)}

    var localeMap = d3.map(theData);

    var scatterTooltip = d3.select("body")
            .append("div")
            .attr("id", "scatterTooltip")
            .attr("class", "tooltip")
            .style("position", "absolute")
            .style("z-index", "10")
            .style("visibility", "hidden")
            .html("");

    //var scatterArray = [];
    var fieldTitles = [];

    // Create dropdown axis plot controls
    d3.csv("data/census_field_map.csv", function(error, fieldData) {

        for ( i in fieldData){
            // Only grab top level keys, ignore groups
            if (fieldData[i]["grouped"] == 0){
                fieldTitles.push([fieldData[i]["key"], fieldData[i]["title"]]);
            }
        }

        var xSelect = d3.select("#xAxisSelectSpan").append("select")
                .attr("id", "xAxisSelect")
                .on("change", rePlot)
                .selectAll("option")
                .data(fieldTitles)
                .enter()
                .append("option")
                .attr("value",function(d){return d[0]; })
                .text( function(d){ return d[1]; });

        var ySelect = d3.select("#yAxisSelectSpan").append("select")
                .attr("id", "yAxisSelect")
                .on("change", rePlot)
                .selectAll("option")
                .data(fieldTitles)
                .enter()
                .append("option")
                .attr("value",function(d){return d[0]; })
                .text( function(d){ return d[1]; });

        // Can't seem to get access using D3 so resorted to plain ol' javascript
        document.getElementById("xAxisSelect").value = defaultXMetric;
        document.getElementById("yAxisSelect").value = defaultYMetric;
        $("#mapControlsForScatterplot").show();
        $("#scatterMapControls").show();

    });

//    // Get county name lookup data for tooltip
//    d3.csv("data/data_output_ALL_COUNTIES.csv", function(d) {
//        countyNameMap.set(d.FIPS, d);
//        console.log(countyNameMap.get(1003))
//    });

    var brush = d3.svg.brush()
            .x(x)
            .y(y)
//            .on("mouseover", callTooltip)
            .on("brushstart", brushstart)
            .on("brush", brushmove)
            .on("brushend", brushend);

    //Create SVG element
    var svg = d3.select("#mainScatterplotMap")
            .append("svg")
            .attr("id", 'mainScatterplotMapSVG')
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

//    var race = d3.select("#miniScatterplotMap1")
//            .append("svg")
//            .attr("id", 'race')
//            .attr("class", 'minichart')
//            .attr("width", miniChartWidth)
//            .attr("height", miniChartHeight);
//
//    var occupation = d3.select("#miniScatterplotMap4")
//            .append("svg")
//            .attr("id", 'occupation')
//            .attr("class", 'minichart')
//            .attr("width", miniChartWidth)
//            .attr("height", miniChartHeight);

//    var education = d3.select("#miniScatterplotMap2")
//            .append("svg")
//            .attr("id", 'education')
//            .attr("class", 'minichart')
//            .attr("width", miniChartWidth)
//            .attr("height", miniChartHeight);

    var origin = d3.select("#miniScatterplotMap3")
            .append("svg")
            .attr("id", 'origin')
            .attr("class", 'minichart')
            .attr("width", miniChartWidth)
            .attr("height", miniChartHeight);

    var xMetric = defaultXMetric;
    var yMetric = defaultYMetric;

    function rePlot(){
        console.log("rePlot...");

        var selectedData = selectData();
        var xSel = document.getElementById("xAxisSelect");
        var ySel = document.getElementById("yAxisSelect");

        scaleAxes(selectedData);
        svg.selectAll("#xAxis").call(xAxis);
        svg.selectAll("#yAxis").call(yAxis);

        svg.select("#xAxis").select("#xTitle")
                .text(xSel.options[xSel.selectedIndex].text);

        svg.select("#yAxis").select("#yTitle")
                .text(ySel.options[ySel.selectedIndex].text);

        svg.selectAll("circle")
                .data(selectedData)
                .attr("id", function(d) { return d[0]; })
                .transition(transitionSpeed)
                .attr("cx", function(d) { return x(d[1]); })
//                .transition(transitionSpeed)
                .attr("cy", function(d) { return y(d[2]); })
//                .transition(transitionSpeed)
                // if either data point is null set radius to zero
                .attr("r", function(d) { return (d[1] == null || d[2] == null) ? 0 : z(d[3]); });
    }

    function plotMiniGraphs(brushedKeys){
        if (brushedKeys.length){
            plotRaceMini(brushedKeys);
            plotEducationMini(brushedKeys);
            plotOriginMini(brushedKeys);
        }
    }

    function plotRaceMini(brushedKeys){
        var aggregateData = [
            {"label":"Black.", "value":0},
            {"label":"Amer. Ind.", "value":0},
            {"label":"Asian", "value":0},
            {"label":"Pac. Isl.", "value":0},
            {"label":"White", "value":0},
            {"label":"Other", "value":0},
            {"label":"Mixed", "value":0}
        ];
        var totalPop = 0;

        for (i in brushedKeys){
            var pop = localeMap.get(brushedKeys[i])['pop']
            totalPop += pop;
            aggregateData[0].value += (localeMap.get(brushedKeys[i])["race"].afAmPct * 0.01 * pop);
            aggregateData[1].value += (localeMap.get(brushedKeys[i])["race"].amIndPct * 0.01 * pop);
            aggregateData[2].value += (localeMap.get(brushedKeys[i])["race"].asianPct * 0.01 * pop);
            aggregateData[3].value += (localeMap.get(brushedKeys[i])["race"].pacIslandPct * 0.01 * pop);
            aggregateData[4].value += (localeMap.get(brushedKeys[i])["race"].whitePct * 0.01 * pop);
            aggregateData[5].value += (localeMap.get(brushedKeys[i])["race"].otherPct * 0.01 * pop);
            aggregateData[6].value += (localeMap.get(brushedKeys[i])["race"].moreThanOnePct * 0.01 * pop);
        }

        for (i in aggregateData){
            aggregateData[i].value = (aggregateData[i].value/totalPop) * 100;
        }

        $("#miniScatterplotMap1Title").html("Race");
        drawMiniBarChart(aggregateData, "miniScatterplotMap1", "raceSVG", 200, 150, colorbrewer.Set2[8][2] )
    }

    function plotEducationMini(brushedKeys){
        var aggregateData = [
            {"label":"No HS", "value":0},
            {"label":"Some HS", "value":0},
            {"label":"HS Degree", "value":0},
            {"label":"Some College", "value":0},
            {"label":"Associates", "value":0},
            {"label":"Bachelors", "value":0},
            {"label":"Masters", "value":0}
        ];
        var totalPop = 0;

        for (i in brushedKeys){
            var pop = localeMap.get(brushedKeys[i])['pop']
            totalPop += pop;
            aggregateData[0].value += (localeMap.get(brushedKeys[i])["ed"].noHSPct * 0.01 * pop);
            aggregateData[1].value += (localeMap.get(brushedKeys[i])["ed"].someHSPct * 0.01 * pop);
            aggregateData[2].value += (localeMap.get(brushedKeys[i])["ed"].hsPct * 0.01 * pop);
            aggregateData[3].value += (localeMap.get(brushedKeys[i])["ed"].someCollegePct * 0.01 * pop);
            aggregateData[4].value += (localeMap.get(brushedKeys[i])["ed"].asPct * 0.01 * pop);
            aggregateData[5].value += (localeMap.get(brushedKeys[i])["ed"].bsPct * 0.01 * pop);
            aggregateData[6].value += (localeMap.get(brushedKeys[i])["ed"].msPct * 0.01 * pop);
        }

        for (i in aggregateData){
            aggregateData[i].value = (aggregateData[i].value/totalPop) * 100;
        }

        $("#miniScatterplotMap2Title").html("Education");
        drawMiniBarChart(aggregateData, "miniScatterplotMap2", "educationSVG", 200, 150, colorbrewer.Set2[8][3] )
    }

    function plotOriginMini(brushedKeys){
        var aggregateData = [
            {"label":"In State", "value":0},
            {"label":"In US.", "value":0},
            {"label":"Foreign Born", "value":0}
        ];

        for (i in brushedKeys){
            var pop = localeMap.get(brushedKeys[i])['pop']
            aggregateData[0].value += (localeMap.get(brushedKeys[i])["birth"].inStatePct * 0.01 * pop);
            aggregateData[1].value += (localeMap.get(brushedKeys[i])["birth"].outStatePct * 0.01 * pop);
            aggregateData[2].value += (localeMap.get(brushedKeys[i])["birth"].foreignBornPct * 0.01 * pop);
        }
        $("#miniScatterplotMap3Title").html("Origin");
        plotMiniPie(aggregateData, "Origin", "#origin", colorbrewer.Set1[8]);
    }


    function plotMiniPie(data, title, elementID, colorScheme){
        var colorRange = d3.scale.ordinal() //builtin range of colors
                .range(colorScheme);

        //Set title
        $( elementID + "Title").html(title);

        var otherValue = 0;

        for ( i in data){

            if (data[i].value < 10)
                console.log(" Under 10: " + data[1].label + ": " + data[1].value);
        }

        var vis = d3.select(elementID).selectAll("pieGroup")
                .data([data])
                .enter()
                .append("g")
                .attr("class", 'pieGroup')
                .attr("transform", "translate(" + miniChartTranslate + "," + (miniChartTranslate + 10) + ")");

        var arc = d3.svg.arc() //create <path> elements using arc data
                .outerRadius(miniRadius);

        var pie = d3.layout.pie() //create arc data from list of values
                .value(function(d) { return d.value; });

        var arcs = vis.selectAll("slice")
                .data(pie)
                .enter()
                .append("g")
                .attr("class", "slice")

        arcs.append("path")
                .attr("fill", function(d, i) { return colorRange(i); } )
                .attr("d", arc);

        arcs.append("text") //add a label to each slice
                .attr("transform", function(d) {
                    d.innerRadius = 0;
                    d.outerRadius = miniRadius;
                    var labelX = arc.centroid(d)[0];
                    var labelY = arc.centroid(d)[1];
                    var h = Math.sqrt(Math.pow(labelX,2) + Math.pow(labelY,2)); // Get hypotenuse
                    var cos = Math.sin(labelX/h); // Get sin and cos of opposite and adjacent angles
                    var sin = Math.sin(labelY/h);
                    // Calculate new coordinates using desired hypotenuse (distance from center) and sin and cos.
                    labelX = cos * (miniRadius * 0.75); // Set distance from center to 75% of radius
                    labelY = sin * (miniRadius * 0.75);
                    console.log(labelX + ":" + labelY);
                    // Set transform translation to new coordinates
                    return "translate(" +
                            [labelX, labelY] + ")";
                })
                .attr("text-anchor", "middle")
                .text(function(d, i) { return data[i].label; }); //get the label from data array
    }

    function selectData(){
        if (firstPlot){
            firstPlot = false;
        } else
        {
            xMetric = document.getElementById("xAxisSelect").value;
            yMetric = document.getElementById("yAxisSelect").value;
            console.log(xMetric + ":" + yMetric);
        }
        var selectedData = [];
        localeMap.forEach(function(d){
            selectedData.push([d,localeMap.get(d)[xMetric],localeMap.get(d)[yMetric],localeMap.get(d)['pop']]);
        });
        return selectedData
    }

    var scatterData = selectData();
    scaleAxes(scatterData);

    svg.append("g")
            .attr("id", "xAxis")
            .attr("transform", "translate(0," + theHeight + ")")
            .call(xAxis)
            .append("text")
            .attr("id", "xTitle")
            .attr("class", "axisTitle")
            .attr("x", theWidth/2)
            .attr("y", 30)
            .attr("dy", ".71em")
            .style("text-anchor", "middle")
            .text(defaultXTitle);

    svg.append("g")
            .attr("id", "yAxis")
            .call(yAxis)
            .append("text")
            .attr("id", "yTitle")
            .attr("class", "axisTitle")
            .attr("transform", "rotate(-90)")
            .attr("x", -(theHeight/2))
            .attr("y", -80)
            .attr("dy", ".71em")
            .style("text-anchor", "middle")
            .text(defaultYTitle);

    // Code for brushing data points
    svg.call(brush);

    var circle = svg.selectAll("circle")
            .data(scatterData)
            .enter()
            .append("circle")
            .attr("id", function(d) { return d[0]; })
            .attr("cx", function(d) { return x(d[1]); })
            .attr("cy", function(d) { return y(d[2]); })
            .attr("r", function(d) { return (d[1] == null || d[2] == null) ? 0 : z(d[3]); })
            .on("mouseover", function(d) {
                return scatterTooltip.style("visibility", "visible");
//                console.log("turning on tooltip");
            })
            .on("mousemove", function(d) {

                var tooltipText = "<h4>" + localeMap.get(d[0]).locale + ", ";
                tooltipText += localeMap.get(d[0]).state + "</h4>";
                tooltipText += "<p>Population: " + d[3].formatNumber(0) + "</b><br>";
                scatterTooltip.html(tooltipText);
                scatterTooltip.attr("class", "tooltip");
                scatterTooltip.style("top", (d3.mouse(this)[1] + 450) + "px").style("left", (d3.mouse(this)[0] + 125) + "px");
//                console.log(d3.mouse(this)[0]);
                return tooltip;
            })
            .on("mouseout", function(d) {
                return scatterTooltip.style("visibility", "hidden");
            });



    function brushstart(p) {
        svg.classed("selecting", true);
        console.log("Start brushing...");
    }

    function brushmove() {
        console.log("Brushing...");
        var e = d3.event.target.extent();
        circle.classed("brushed", function(d) {
            return e[0][0] <= d[1] && d[1] <= e[1][0]
                    && e[0][1] <= d[2] && d[2] <= e[1][1];
        });
    }

    function brushend() {
        svg.classed("selecting", !d3.event.target.empty());
        console.log("Brush ended...");
        updateBrush();

    }

    function updateBrush(){
        var brushedElements = svg.selectAll(".brushed");
        var brushedKeys = [];
        brushedElements[0].forEach( function(d){
            brushedKeys.push(d.id);
        })
        console.log("Brushed points: " + brushedKeys.length);
        console.log(brushedKeys);
        plotMiniGraphs(brushedKeys);
    }

});
</script>
</body>
</html>